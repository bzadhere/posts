---
title: 网络字节序
date: 2019-01-24 09:24:04
tags:
categories: 网络
---

# 理解字节序
> 大端字节序：高位字节在前, 低位字节在后, 是人类读取字节的方法
> 小端字节序：低位字节在前, 高位字节在后  

int32 num = 0x1234567的大端字节序和小端字节序的写法如下

| 地址 | 0x100 | 0x101 | 0x102 | 0x103 |
| - | :- | :- | :- | :- |
|大端|0x01|0x23|0x45|0x67|
|小端|0x67|0x45|0x23|0x01|

# 网络字节序
网络字节顺序采用大端字节序, 是TCP/IP中规定好的一种数据表示格式;  
与具体的CPU类型、操作系统等无关, 保证数据在不同主机之间传输时能够被正确解释。


# 主机字节序

| 处理器  | 操作系统 | 字节排序 |
|:-|:-|:-|
| Alpha | 全部 | Little endian |
|HP-PA       |     NT      | Little endian  |
|HP-PA       |     UNIX    | Big endian     |
|Intelx86    |     全部    | Little endian  |
|Motorola680x|     全部    | Big endian     |
|MIPS        |     NT      | Little endian  |
|MIPS        |     UNIX    | Big endian     |
|PowerPC     |     NT      | Little endian  |
|PowerPC     |     非NT    | Big endian     |
|RS/6000     |     UNIX    | Big endian     |
|SPARC       |     UNIX    | Big endian     |
|IXP1200     |     ARM核心 | Little endian  |

# 字节序判断
```
inline int64 htonl64(const char* pIn )
{
	if (pIn == NULL)
	{
		return 0;
	}
	
	int32 nIsNet = 0x12345678;
	if (*(char *)&nIsNet == 0x12)
	{
		nIsNet = 1;
	}
	else
	{
		nIsNet = 0;
	}      
	
	unsigned char szBuffer[16];
	
	if (nIsNet == 1)
	{
		memcpy(szBuffer, pIn, 8);
	}
	else
	{
		for (int32 i = 0, j = 7; i < 8; ++i, --j)
		{
			szBuffer[i] = pIn[j];
		}
	}
	int64 llValue;
	memcpy(&llValue, szBuffer, sizeof(int64));
	return llValue;
};

inline int64 ntohl64(const char* pIn )
{
	if (pIn == NULL)
	{
		return 0;
	}
	
	int32 nIsNet = 0x12345678;
	
	if (*(char *)&nIsNet == 0x12)
	{
		nIsNet = 1;
	}
	else
	{
		nIsNet = 0;
	}
	
	unsigned char szBuffer[8];
	
	if (nIsNet == 1)
	{
		memcpy(szBuffer, pIn, 8);
	}
	else
	{
		//!< 取高4字节.
		int32 nRetH;
		int32 nTmpRetH;
		memcpy(&nTmpRetH, pIn, sizeof(int32));
		nRetH = ntohl(nTmpRetH);
		
		//!< 取低4字节.
		int32 nRetL;
		int32 nTmpRetL;
		memcpy(&nTmpRetL, pIn + sizeof(int32), sizeof(int32));
		nRetL = ntohl(nTmpRetL);
		
		//! 整合.
		memcpy(szBuffer, &nRetL, sizeof(int32));
		memcpy(szBuffer + sizeof(int32), &nRetH, sizeof(int32));
	}
	int64 llValue;
	memcpy(&llValue, szBuffer, sizeof(int64));
	return llValue;
};
```


# 32位整数转换为网络字节序
```
/* 大端字节序 */
i = (data[0]<<24) | (data[1]<<16) | (data[2]<<8) | (data[3]<<0);

/* 小端字节序 */
i = (data[0]<<0) | (data[1]<<8) | (data[2]<<16) | (data[3]<<24);
```
